# 클린 아키텍처

소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. (비용은 최소화하고 생산성은 최대화한다)

```
다시 읽으며 추후 챕터별로 정리할 예정입니다.
```

# Summary

아키텍처의 주된 목적은 시스템을 쉽게 이해하고 쉽게 개발하며 쉽게 유지보수하고 또 쉽게 배포하게 하는 것이다. 즉 시스템의 생명주기를 지원하는 것과 관련된 비용은 최소화하고 개발자의 생산성을 최대화하는 데 있다.

이를 위해서 고수준의 정책(업무 규칙 또는 비즈니스 로직)과 저수준의 세부사항(입출력 장치, 데이터베이스, 웹 시스템, 프레임워크, 통신 프로토콜 등)을 분리해야 한다. 물론 정책은 어떤 경우에도 세부사항에 의존하지 않아야 하며 세부사항에 대한 결정은 최대한 미룰 수 있어야 한다. 즉, 정책과 세부사항이 의존할 추상 인터페이스를 우선적으로 설계하고 구현해야 한다.


## 소프트웨어

- 부드러운(soft) 제품(ware)
- 소프트웨어가 가진 본연의 목적을 추구하려면 소프트웨어는 반드시 `부드러워`야한다. (변경하기 쉬워야한다)

`아키텍트는 이러한 특성과 기능을 개발하기 쉽고, 간편하게 수정할 수 있으며, 확장하기 쉬운 아키텍처를 만들어야 한다.`

## 패러다임

- 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다.
- 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용해야 하는지를 결정한다.

### 구조적 프로그래밍

제어흐름의 직접적인 전환에 대해 규칙을 부과한다.

모듈, 컴포넌트, 서비스가 테스트하기 쉽도록 만들기 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.

### 객체 지향 프로그래밍

제어흐름의 간접적인 전환에 대해 규칙을 부과한다.

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는데서 출발한다.

다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. 

- 캡슐화(encapsulation)
    - 데이터와 함수가 응집력 있게 구성된 집단을 서로 구분 짓는 선을 그을 수 있다.
    - 구분선 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다.
    - ex) 노출되어 있는 함수를 호출하면 내부 구조나 실행방식을 알수가 없다.
- 상속(inheritance)
    - 어떤 변수와 함수를 하나의 유효 범위로 묶어서 재정의하는 일
- 다형성(polymorphism)
    - 의존성 역전

### 함수형 프로그래밍

할당문에 대해 규칙을 부과한다.

- 불변성과 아키텍처
    - Race condition(경합 조건), Deadlock 조건, Concurrent update(동시 업데이트) 문제가 모두 가변 변수로 인해 발생하기 때문에 중요하다..
    - 다수의 스레드와 프로세스를 사용하는 애플리케이션에서 마주치는 모든 문제는 가변 변수가 없다면 절대로 생기지 않는다.
- 가변성의 분리
    - 트랜잭선 메모리
    - 애플리케이션을 제대로 구조화하려면 변수를 변경하는 컴포넌트와 변경하지 않는 컴포넌트를 분리해야 한다.
    - 추가적으로 가변 변수들을 보호하는 적절한 수단을 동원해 뒷받침해야한다.
    - 현명한 아키텍트라면 가능한 한 많은 처리를 불변 컴포넌트로 옮겨야 하고, 가변 컴포넌트에서는 가능한 한 많은 코드를 빼내야 한다.
- 이벤트 소싱
    - 상태가 아닌 트랜잭션을 저장하자는 전략
    - 상태가 필요해지면 단순히 상태의 시작점부터 모든 트랜잭션을 처리한다.

`소프트웨어, 즉 컴퓨터 프로그램은 순차, 분기, 반복, 참조로 구성된다.`

## 설계 원칙 (SOLID)

좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는 데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

중간 수준이라 함은 프로그래머가 이들 원칙을 모듈 수준에서 작업할 때 적용할 수 있다는 뜻이다.

즉, 코드 수준보다는 조금 상위에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는 데 도움을 준다.

### 단일 책임 원칙(Single Responsibility Principle)

각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

- 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.
- 서로 다른 액터가 의존하는 코드를 서로 분리하라
- 서로 다른 액터를 뒷받침하는 코드를 서로 분리

### 개방-폐쇄 원칙(Open-Closed Principle)

기존 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경 할 수 있다는 것

- 소프트웨어 개체(artifac)는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야한다.
- OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많은 영향을 받지 않도록 하는 데 있다.
- 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어지도록 해야한다.

### 리스코프 치환 원칙(Liskov Subsitution Principle)

상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 반드시 지켜야 한다.

### 인터페이스 분리 원칙(Interface Segregation Principle)

소프트웨어 설계자는 사용하지 않은 것에 의존하지 않아야 한다.

### 의존성 역전 원칙(dependency Inversion Principle)

고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.

- 안정된 추상화
    - 변동성이 큰 구체 클래스를 참조하지 말라.
    - 변동성이 큰 구체 클래스로부터 파생하지 말라.
    - 구체 함수를 오버라이드 하지 말라.
    - 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라.

## 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해 준다. (대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다)

### 컴포넌트

배포 단위로 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위

자바의 경우 jar, 닷넷의 경우 DLL, 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체, 인터프리터형 언어의 경우 소스파일의 결합체

여로 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다. 또는 여러 컴포넌트를 서로 묶어서 .war 파일과 같은 단일 아카이브로만들 수 있다.

컴포넌트가 마지막에 어떤 형태로 배포되든, 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 가능한, 따라서 독립적으로 개발 가능한 능력을 갖춰야 한다.

### 컴포넌트 응집도

- 재사용/릴리스 등가 원칙(Reuse/Release Equivalence Principle)
    
    재사용 단위는 릴리스 단위와 같다
    

- 공통 폐쇄 원칙(Common Closure Principle)
    
    동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.
    
- 공통 재사용 원칙(Common Resue Principle)
    
    컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.(필요하지 않은 것에 의존하지 말라)
    
![Untitled](https://github.com/crongcm/books/assets/113030711/e4296abb-f07d-4deb-9a04-b7a5c6b9e14a)

어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다. 이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다. 심지어 이 균형점은 거의 유동적이다.

### 컴포넌트 결합

- 의존성 비순환 원칙(Acyclic Dependencies Principle)
    
    컴포넌트 의존성 그래프에 순환이 있어서는 안된다.
    
    - 순환 끊기
        - 의존성 역전 원칙을 적용한다.
        - 두 컴포넌트가 모두 의존하는 새로운 컴포넌트를 만든다.
    - 흐트러짐(Jitters)
        
        의존성 구조에 순환이 발생하는지를 항상 관찰하고, 발생하면 어떤식으로든 끊어야한다.
        
        때때로 새로운 컴포넌트를 생성하거나 의존성 구조가 더 커질 수 있음을 의미한다.
        

- 하향식(top-down) 설계
    
    컴포넌트 의존성 구조는시스템의 논리적 설계에 발 맞춰 성장하며 또 진화해야 한다.
    

- 안정된 의존성 원칙
    
    안정성의 방향으로(더 안정된 쪽에) 의존하라
    
    - 변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다.
    - 한번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다.
    
    안정된 컴포넌트
    
    ![Untitled 1](https://github.com/crongcm/books/assets/113030711/4b868323-26cb-46cf-bdd5-9b85aa30268e)


불안정한 컴포넌트

![Untitled 2](https://github.com/crongcm/books/assets/113030711/f79643a1-3250-4156-af5d-f618ddace266)

- 안정성
    
    안정성 지표
    
    ![Untitled 3](https://github.com/crongcm/books/assets/113030711/9316ce8f-e562-492d-9283-40ea1cb7eb9f)

- 안정된 추상화 원칙(Stable Abstractions Principle)
    
    안정된 컴포넌트는 추상 컴포넌트여야 하며, 이를 통해 안정성이 컴포넌트를 확장하는 일을 방해해서는 안된다고 말한다.
    

의존성 관리 지포는 설계의 의존성과 추상화 정도가 내가 훌륭한 패턴이라고 생각하는 수준에 얼마나 잘 부합하는지를 측정한다.

## 아키텍처

시스템을 구축했던 사람들이 만들어낸 시스템의 형태

그 모양은 시스템을 컴포넌트로 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통 하는 방식에 따라 달라진다.

그 형태는 아키텍처 안에 담긴 소프트웨어 시스템이 쉽게 개발, 배포, 운영, 유지보수되도록 만들어진다.

아키텍처의 궁극적인 목포는 시스템의 수명과 관련된 비용은 최소화하고, 프로그래머의 생산성은 최대화하는 데 있다.

소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 한 많이, 그리고 가능한 한 오랫동안 열어 두는 것이다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다.

세부사항에 몰두하지 않은 채 고수준의 정책을 만들 수 있다면, 이러한 세부사항에 대한 결정을 오랫동안 미루거나 연기할 수 있다. 이러한 결정을 더 오래 참을 수 있다면, `더 많은 정보를 얻을 수 있고, 이를 기초로 제대로 된 결정을 내릴 수 있다.`

좋은 아키텍트는 결정되지 않은 사항의 수를 최대화 한다.

## 경계: 선 긋기

경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다.

시스템의 업무 요구사항, 즉 유스케이스와 아무런 관련이 없는 결정(프레임워크, 데이터베이스, 웹 서버, 유틸리티 라이브로리, 의존성 주입에 대한 결정 등) 이러한 결정이 부수적이며, 결정을 연기할 수 있는, 결정에 따른 영향이 크지 않는 아키텍처

### 어떻게 선을 그을까? 그리고 언제 그을까?

관련이 있는 것과 없는 것 사이에 선을 긋는다.

### 플러그인 아키텍처

플러그인을 손쉽게 생성하여, 확장 가능하며 유지보수가 쉬운 시스템 아키텍처를 확립할 수 있게 만드는 방법

소프트웨어 아키텍처에서 경계선을 그리려면 먼저 시스템을 컴포넌트 단위로 분할해야 한다. 일부 컴포넌트는 핵심 업무 규칙에 해당하고, 나머지 컴포넌트는 플러그인으로, 핵심 업무와는 직접적인 관련이 없지만 필수 기능을 포함한다. `의존성 화살표는 저수준 세부사항에서 고수준의 추상화를 향하도록 배치`

## 경계 해부학

단일체를 제외한 대다수 시스템은 한 가지 이상의 경계 전략을 사용한다.

대체로 한 시스템 안에서도 통신이 빈번한 로컬 경계와 지연을 중요하게 고려해야하는 경계가 혼합되어 있음을 의미한다.

저수준 프로세스가 고수준 프로세스의 플러그인이 되도록 만드는 것이 아키텍처관점의 목표(의존성 저수준 → 고수준)

## 정책과 수준

컴퓨터 프로그램은 각 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서이다.

좋은 아키펙처라면 각 컴포넌트를 연결할 때 의존성의 방향이 컴포넌트의 수준을 기반으로 연결되도록 만들어야 한다. 즉, `저수준 컴포넌트가 고수준 컴포넌트에 의존하도록 설계되어야 한다.`

### 수준

`수준`을 엄밀하게 정의하자면 `입력과 출력까지의 거리`다

- 시스템의 입력과 출력 모두로 부터 멀리 위치할 수록 정책의 수준은 높아진다.(입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다)

## 업무 규칙

사업적으로 수익을 얻거나 비용을 줄일 수 잇는 규칙 또는 절차

핵심 규칙과 핵심 데이터는 본질적으로 결합되어 있기 때문에 객체로 만들 좋은 후보가 된다.

이러한 유형의 객체를 `Entity`라고 한다

### 엔티티

컴퓨터 시스템 내부의 객체로서, 핵심 업무 데이터를 기반으로 동작하는 일련의 조그만 핵심 업무 규칙을 구체화한다.

### 유스케이스

사용자가 제공해야 되는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다.

(애플리케이션에 특화된 업무 규칙을 설명한다.)

엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출 할지를 명시하는 규칙을 담는다.

![Untitled 4](https://github.com/crongcm/books/assets/113030711/29b9f689-2e96-44e8-99bf-7987bbaa2533)

유스케이스는 엔티티에 의존한다. 반면 엔티티는 유스케이스에 의존하지 않는다. (엔티티=고수준, 유스케이스=저수준)

업무 규칙은 소프트웨어 시스템이 존재하는 이유다. 업무 규칙은 핵심적인 기능이다.

업무 규칙을 표현하는 코드는 반드시 시스템의 심장부에 위치해야 하며, 덜 중요한 코드는 이 심장부에 플러그인되어야 한다. 업무 규칙은 시스템에서 가장 독립적이며 가장 많이 재사용할 숭 ㅣㅆ는 코드여야 한다.

## 소리치는 아키텍처

소프트웨어 애플리케이션의 아키텍처는 애플리케이션의 유스케이스에 대해 소리쳐야 한다.

엔티티는 가장 오래된 방식의 간단한 객체여야 하며, 프레임워크나 데이터베이스, 또는 여타 복잡한 것들에 의존해서는 안된다. `유스케이스 객체가 엔티티 객체를 조작해야 한다.` 프레임워크로 인한 어려움을 겪지 않고도 반드시 이 모두를 있는 그대로 테스트할 수 있어야 한다.

아키텍처는 시스템을 이야기해야 하며, 새로 온 프로그래머는 시스템이 어떻게 전달될지 알지 못한 상태에서도 시스템의 모든 유스케이스를 이해할 수 있어야 한다.

## 클린 아키텍처

소프트웨어를 계층으로 분리함으로써 관심사의 분리(separation of concerns)라는 목표를 달성할 수 있다.

각 아키텍처는 최소한 업무규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 만드시 포함한다.

모든 아키텍처는 각 특징을 지니도록 만든다.

- 프레임워크 독립성
- 테스트 용이성
- UI 독립성
- 데이터베이스 독립성
- 모든 외부 에이전시에 대한 독립성

![Untitled 5](https://github.com/crongcm/books/assets/113030711/b29e4e8c-046a-4854-ac41-9f43ebf27a59)

### 의존성 규칙

각각의 동심원은 소프트웨어에서 서로 다른 영역을 표현한다. (보통 안으로 들어갈수록 고수준의 소프트웨어)

`소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.`

외부 원은 어떠한 것이더라도 내부 원에 영향을 줄 수 없다.(함수, 클래스, 변수, 엔티티 등 모든 것)

### 엔티티

전사적인 핵심 업무 규칙을 캡슐화 한다.

특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다.

### 유스케이스

애플리케이션에 특화된 업무 규칙을 포함한다.

엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.

이 계층에서 발생한 변경이 엔티티에 영향을 줘서는 안 안되. 또한 데이터베이스, UI, 또는 여타 공통 프레임워크와 같은 외부요소에서 발생한 변경이 이 계층에 영향을 줘서도 안 된다.

### 인터페이스 어댑터

어댑터는 데이터를 유스케이스와 엔티티에게 가장 편리한 형식에서 데이터베이스나 웹 같은 외부 에이전시에게 가장 편리한 형식으로 변환한다.

프레젠터, 뷰, 컨트롤터는 모두 인터페이스 어댑터 계층에 속한다.

데이터를 외부 서비스와 같은 외부적인 형식에서 유스케이스나 엔티티에서 사용되는 내부적인 형식으로 변환하는 또 다른 어댑터가 필요하다.

### 프레임워크와 드라이버

가장 바깥쪽 계층은 일반적으로 데이터베이스나 웹 프레임워크 같은 프레임워크나 도구들로 구성된다.

세부사항으로, 이러한 것들을 모두 외부에 위치시켜서 피해를 최소화한다.

소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.

## 프레젠터와 험블 객체

프레젠터는 험블 객체 패턴을 따른 형태로, 아키텍처 경계를 식별하고 보호하는 데 도움이 된다.

### 험블 객체 패턴

테스트하기 어려운 행위와 테스트하기 쉬운 행위를 단위 테스트 작성자가 분리하기 쉽게 하는 방법으로 고안

테스트하기 어려운 행위를 모두 험블 객체로 옮기고, 테스트하기 쉬운 행위 테스트를 다른 객체로 옮긴다.

### 프레젠터와 뷰

뷰는 험블 객체이고 테스트하기 어렵다. 이 객체에 포함된 코드는 가능한 한 간단하게 유지한다.

프레젠터는 테스트하기 쉬운 객체다. 애플리케이션으로부터 데이터를 받아 화면에 표현할 수 있는 포맷으로 만드는 것이다.

아키텍처 경계에서 험블 객체 패턴을 사용하면 전체 시스템의 테스트 용이성을 크게 높일 수 있다.

## 부분적 경계

아키텍처 경계가 언제, 어디에 존재해야 할지, 그리고 그 경계를 완벽하게 구현할지 아니면 부분적으로 구현할지를 결정하는 일 또한 아키텍트의 역할이다.

## 계층과 경계

오버 엔지니어링이 언더 엔지니어링보다 나쁠 때가 훨씬 많다.

첫 조짐이 보이는 시점이 되면, 해당 경계를 구현하는 비용과 무시할 때 감수할 비용을 가늠해 본다.

그리고 결정된 사항을 자주 검토한다. 우리의 목표는 경계의 구현 비용이 그걸 무시해서 생기는 비용보다 적어지는 바로 그 변곡점에서 경계를 구현하는 것이다.

## 메인 컴포넌트

메인 컴포넌트는 궁극적인 세부사항으로, 가장 낮은 수준의 정책이다.

클린 아키텍처에서 가장 바깥 원에 위치하는, 지저분한 저수준 모듈으로 고수준의 시스템을 위한 모든 것을 로드한 후, 제어권을 고수준의 시스템에게 넘긴다.

초기조건과 설정을 구성하고, 외부자원을 모두 수집한 후,제어권을 애플리케이션의 고수준 정책으로 넘기는 플러그인이다.

메인을 플러그인 컴포너트로 여기고, 그래서 아키텍처 경계 바깥에 위치한다고 보면 설정 관련 문제를 훨씬 쉽게 해결할 수 있다.

## 크고 작은 모든 서비스들

서비스는 시스템의 확장성과 개발 가능성 측면에서 유용하지만, 그 자체로는 아키텍처적으로 그리 중요한 요소는 아니다.

시스템의 아키텍처는 시스템 내부에 그어진 경계와 경계를 넘나드는 의존성에 의해 정의된다.

## 테스트 경계

테스트는 시스템의 일부이며, 아키텍처에도 관여한다.

테스트는 태생적으로 의존성 규칙을 따른다. 테스트는 세부적이며 구체적인 것으로, 의존성은 항상 테스트 대상이 되는 코드를 향한다.

변동성이 있는 것에 의존하지 말라.

GUI로 시스템을 조작하는 테스트 스위트는 분명 깨지기 쉽다. 따라서 시스템과 테스트를 설계할 때, GUI를 사용하지 않고 업무 규칙을 테스트할 수 있게 해야 한다.

## 클린 임베디드 아키텍처

소프트웨어는 닳지 않지만, 펌웨어와 하드웨어에 대한 의존성을 관리하지 않으면 안으로부터 파괴될 수 있다.

HAL을 추가하거나 때로는 OSAL을 추가해야 할 뿐만 아니라, 모든 주요 계층(소프트웨어, OS, 펌웨어, 하드웨어) 내부에는 이 책에서 설명한 원칙들을 적용해야 한다. 이들 원칙은 관심사를 분리시키고, 인터페이스를 활용하며, 대채 가능성을 높이는 방향으로 프로그래밍하도록 유도한다.

## 세부사항

### 데이터 베이스

애플리케이션 내부 데이터의 구조는 시스템 아키텍처에서 대단히 중요하다., 하지만 데이터베이스는 일개 소프트웨어일 뿐이다.

### 웹

웹은 입출력 장치다.

GUI는 세부사항이다. 웹은 GUI다. 따라서 웹은 세부사항이다.

### 프레임워크
